category: Data Enrichment & Threat Intelligence
commonfields:
  id: RSS Feed
  version: -1
configuration:
- additionalinfo: The RSS URL should be a URL with 'feed' as the suffix or prefix.
  display: Feed URL
  name: server_url
  required: true
  type: 0
- additionalinfo: Default is 45KB. If you increase the limit substantialy, it may
    slow performance. You need to specify only a number, e.g., 50.
  defaultvalue: "45"
  display: Article content max size in KB
  name: max_size
  required: false
  type: 0
- additionalinfo: Default is 20 seconds. In cases content is too long, Read Timeout
    Error is return, to handle it increase the read timeout value.
  defaultvalue: "20"
  display: Read Timeout
  name: read_timeout
  required: false
  type: 0
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation
  defaultvalue: feedInstanceReputationNotSet
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: F - Reliability cannot be judged
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed.
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- defaultvalue: indicatorType
  display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- defaultvalue: "20160"
  display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "240"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.2.0
    itemVersion: 1.0.8
    packID: FeedRSS
    packName: RSS Feed
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: RSS Feed reader can ingest new items as report indicators.
detaileddescription: "\n## Configure the Integration\n\nTo fetch from several feeds,
  you need to configure an instance to each feed.\n\nThe following are popular security
  news feeds you can use in the Feed URL field: \n\n[https://threatpost.com/feed/](https://threatpost.com/feed/)\n\n[https://www.securitymagazine.com/rss/articles](https://www.securitymagazine.com/rss/articles)\n\n[https://www.darkreading.com/rss_feeds.asp](https://www.darkreading.com/rss_feeds.asp)\n\n[https://feeds.feedburner.com/TheHackersNews](https://feeds.feedburner.com/TheHackersNews)\n\nThe
  following are Palo Alto Networks Feed source examples:\n\n[https://unit42.paloaltonetworks.com/feed/](https://unit42.paloaltonetworks.com/feed/)\n\n[https://status.paloaltonetworks.com/history.rss](https://status.paloaltonetworks.com/history.rss)\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/rss-feed)"
display: RSS Feed
image: data:image/png;base64,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
name: RSS Feed
script:
  commands:
  - arguments:
    - defaultValue: "10"
      description: The maximum number of indicators to return.
      name: limit
    description: Gets the reports from the RSS feed.
    name: rss-get-indicators
  dockerimage: demisto/py3-tools:1.0.0.31193
  feed: true
  runonce: false
  script: |
    register_module_line('RSS Feed', 'start', __line__())
    ### pack version: 1.0.8
    import feedparser


    from bs4 import BeautifulSoup

    HTML_TAGS = ['p', 'table', 'ul', 'ol', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']

    INTEGRATION_NAME = 'RSS Feed'


    class Client(BaseClient):
        """Client for RSS Feed - gets Reports from the website
        Attributes:
            server_url(str): The RSS URL.
            use_ssl: Whether to use ssl.
            proxy(str): Use system proxy.
        """

        def __init__(self, server_url, use_ssl, proxy, reliability, feed_tags, tlp_color, content_max_size=45,
                     read_timeout=20):
            super().__init__(base_url=server_url, proxy=proxy, verify=use_ssl)
            self.feed_tags = feed_tags
            self.tlp_color = tlp_color
            self.content_max_size = content_max_size * 1000
            self.parsed_indicators = []
            self.feed_data = None
            self.reliability = reliability
            self.read_timeout = read_timeout

        def request_feed_url(self):
            return self._http_request(method='GET', resp_type='response', timeout=self.read_timeout,
                                      full_url=self._base_url)

        def parse_feed_data(self, feed_response):
            try:
                if feed_response:
                    self.feed_data = feedparser.parse(feed_response.text)
            except Exception as err:
                raise DemistoException(f"Failed to parse feed.\nError:\n{str(err)}")

        def create_indicators_from_response(self):
            parsed_indicators: list = []
            if not self.feed_data:
                raise DemistoException(f"Could not parse feed data {self._base_url}")

            for indicator in reversed(self.feed_data.entries):
                publications = []
                if indicator:
                    published = dateparser.parse(indicator.published)
                    if not published:
                        continue
                    published_iso = published.strftime('%Y-%m-%dT%H:%M:%S')
                    publications.append({
                        'timestamp': indicator.get('published'),
                        'link': indicator.get('link'),
                        'source': self._base_url,
                        'title': indicator.get('title')
                    })
                    text = self.get_url_content(indicator.get('link'))
                    if not text:
                        continue
                    indicator_obj = {
                        "type": 'Report',
                        "value": indicator.get('title').replace(',', ''),  # Remove comma because the script of create
                        # relationship includes that as a list of titles.
                        "rawJSON": {'value': indicator, 'type': 'Report', "firstseenbysource": published_iso},
                        "reliability": self.reliability,
                        "fields": {
                            'rssfeedrawcontent': text,
                            'publications': publications,
                            'description': indicator.get('summary'),
                            'tags': self.feed_tags,
                        }
                    }
                    if self.tlp_color:
                        indicator_obj['fields']['trafficlightprotocol'] = self.tlp_color

                parsed_indicators.append(indicator_obj)

            return parsed_indicators

        def get_url_content(self, link: str) -> str:
            """Returns the link content only from the relevant tags (listed on HTML_TAGS). For better performance - if the
             extracted content is bigger than "content_max_size" we trim him"""

            response_url = self._http_request(method='GET', full_url=link, resp_type='str', timeout=self.read_timeout)
            report_content = 'This is a dumped content of the article. Use the link under Publications field to read ' \
                             'the full article. \n\n'
            soup = BeautifulSoup(response_url.content, "html.parser")
            for tag in soup.find_all():
                if tag.name in HTML_TAGS:
                    for string in tag.stripped_strings:
                        report_content += ' ' + string
            try:
                encoded_content = report_content.encode('utf-8', errors='replace')
            except Exception as err:
                demisto.debug(f"Fail encoding the article content, skipping report {link}. \nError:\n{str(err)}")
                return ""
            if len(encoded_content) > self.content_max_size:  # Ensure report_content does not exceed the
                # indicator size limit (~50KB)
                report_content = encoded_content[:self.content_max_size].decode('utf-8', errors='replace')
                report_content += ' This is truncated text, report content was too big.'

            return report_content


    def fetch_indicators(client: Client):
        feed_response = client.request_feed_url()
        client.parse_feed_data(feed_response)
        parsed_indicators = client.create_indicators_from_response()
        return parsed_indicators


    def get_indicators(client: Client, indicators: list, args: dict) -> CommandResults:
        limit = int(args.get('limit', 10))
        parsed_indicators = indicators[:limit]
        parsed_for_hr = []
        for indicator in parsed_indicators:
            link = indicator.get('fields', {}).get('publications', [{}])[0].get('link')
            article_title = indicator.get('value', '')
            article_field_hr = article_title
            if link:
                article_field_hr = f"[{article_title}]({link})"  # if there is a link to the article, we want the
                # article's title to be a link.
            parsed_for_hr.append({'Article': article_field_hr,
                                  'Type': indicator.get('type')})
        headers = ['Article', 'Type']
        hr_ = tableToMarkdown(name=INTEGRATION_NAME, t=parsed_for_hr, headers=headers)
        return CommandResults(
            readable_output=hr_,
            raw_response=client.feed_data
        )


    def check_feed(client: Client) -> str:
        feed_response = client.request_feed_url()
        if feed_response and 'html' in feed_response.headers['content-type']:
            raise DemistoException(f'{feed_response.url} is not rss feed url. Try look for a url containing xml format data,'
                                   f' that could be found under urls with \'feed\' prefix or suffix.')
        else:
            client.parse_feed_data(feed_response)  # If parse response will raise an error, test will fail.
            return "ok"


    def main():
        params = demisto.params()
        server_url = (params.get('server_url')).rstrip()
        command = demisto.command()
        demisto.info(f'Command being called is {command}')

        try:
            reliability = params.get('feedReliability')
            reliability = reliability if reliability else DBotScoreReliability.F

            if DBotScoreReliability.is_valid_type(reliability):
                reliability = DBotScoreReliability.get_dbot_score_reliability_from_str(reliability)
            else:
                raise Exception("Please provide a valid value for the Source Reliability parameter.")
            client = Client(server_url=server_url,
                            use_ssl=not params.get('insecure', False),
                            proxy=params.get('proxy'),
                            reliability=reliability,
                            feed_tags=argToList(params.get('feedTags')),
                            tlp_color=params.get('tlp_color'),
                            content_max_size=int(params.get('max_size', '45')),
                            read_timeout=int(params.get('read_timeout', '20')))

            if command == 'test-module':
                return_results(check_feed(client))

            elif command == 'rss-get-indicators':
                parsed_indicators = fetch_indicators(client)
                return_results(get_indicators(client, parsed_indicators, demisto.args()))

            elif command == 'fetch-indicators':
                parsed_indicators = fetch_indicators(client)
                for iter_ in batch(parsed_indicators, batch_size=2000):
                    demisto.createIndicators(iter_)
            else:
                raise NotImplementedError(f'Command {command} is not implemented.')

        except Exception as err:
            return_error(f"Failed to execute {INTEGRATION_NAME} with {command} command.\nError:\n{str(err)}")


    if __name__ in ('builtin__', 'builtins', '__main__'):
        main()

    register_module_line('RSS Feed', 'end', __line__())
  subtype: python3
  type: python
system: true
