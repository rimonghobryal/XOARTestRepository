category: Data Enrichment & Threat Intelligence
commonfields:
  id: MalwareBazaar Feed
  version: -1
configuration:
- defaultvalue: https://mb-api.abuse.ch
  display: Server URL
  name: url
  required: true
  type: 0
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation.
  defaultvalue: Bad
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: A - Completely reliable
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed.
  defaultvalue: WHITE
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- defaultvalue: indicatorType
  display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- defaultvalue: "20160"
  display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "30"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- defaultvalue: "true"
  display: Create relationships
  name: create_relationships
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 1.0.38
    packID: FeedMalwareBazaar
    packName: MalwareBazaar Feed
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Use the MalwareBazaar Feed integration to get the list of malware samples
  added to MalwareBazaar within the last 60 minutes.
detaileddescription: "[MalwareBazaar](https://bazaar.abuse.ch/) is a project from
  abuse.ch with the goal of sharing malware samples with the infosec community, AV
  vendors and threat intelligence providers.\nWe are retrieving a list of malware
  samples added to MalwareBazaar within the last 60 minutes.\nThe first fetch doesn't
  bring all the MalwareBazaar's database and only the last 60 minutes. \n### Fetch
  indicators\nTo start fetching indicators, enable the parameter `Fetches indicators`.\nThe
  fetch indicators interval can be adjusted by the parameter `Feed Fetch Interval`.\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/malware-bazaar-feed)"
display: MalwareBazaar Feed
image: data:image/png;base64,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
name: MalwareBazaar Feed
script:
  commands:
  - arguments:
    - defaultValue: "50"
      description: The maximum number of results to return. The default value is 50.
      name: limit
    description: Gets the feed indicators.
    name: malwarebazzar-get-indicators
  dockerimage: demisto/py3-tools:1.0.0.86612
  feed: true
  runonce: false
  script: |
    register_module_line('MalwareBazaar Feed', 'start', __line__())
    ### pack version: 1.0.38


    ### GENERATED CODE ###: from JSONFeedApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('JSONFeedApiModule', 'start', __line__(), wrapper=-3)
    # pylint: disable=E9010


    ''' IMPORTS '''
    import urllib3
    import jmespath
    from typing import List, Dict, Union, Optional, Callable, Tuple

    # disable insecure warnings
    urllib3.disable_warnings()

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    THRESHOLD_IN_SECONDS = 43200        # 12 hours in seconds


    class Client:
        def __init__(self, url: str = '', credentials: dict = None,
                     feed_name_to_config: Dict[str, dict] = None, source_name: str = 'JSON',
                     extractor: str = '', indicator: str = 'indicator',
                     insecure: bool = False, cert_file: str = None, key_file: str = None, headers: Union[dict, str] = None,
                     tlp_color: Optional[str] = None, data: Union[str, dict] = None, **_):
            """
            Implements class for miners of JSON feeds over http/https.
            :param url: URL of the feed.
            :param credentials: username and password used for basic authentication.
             Can be also used as API key header and value by specifying _header in the username field.
            :param extractor: JMESPath expression for extracting the indicators from
            :param indicator: the JSON attribute to use as indicator. Default: indicator
            :param source_name: feed source name
            If None no additional attributes will be extracted.
            :param insecure: if *False* feed HTTPS server certificate will be verified
            Hidden parameters:
            :param: cert_file: client certificate
            :param: key_file: private key of the client certificate
            :param: headers: Header parameters are optional to specify a user-agent or an api-token.
                Support also a multiline string where each line contains a header of the format 'Name: Value'
                Example: headers = {'user-agent': 'my-app/0.0.1'} or "Authorization: Bearer"
                (curl -H "Authorization: Bearer " "https://api-url.com/api/v1/iocs?first_seen_since=2016-1-1")
            :param tlp_color: Traffic Light Protocol color.
            :param data: Data to post. If not specified will do a GET request. May also be passed as dict as
                supported by requests. If passed as a string will set content-type to
                application/x-www-form-urlencoded if not specified in the headers.

             Example:
                Example feed config:
                'AMAZON': {
                    'url': 'https://ip-ranges.amazonaws.com/ip-ranges.json',
                    'extractor': "prefixes[?service=='AMAZON']",
                    'indicator': 'ip_prefix',
                }
            """

            self.source_name = source_name or 'JSON'
            if feed_name_to_config:
                self.feed_name_to_config = feed_name_to_config
            else:
                self.feed_name_to_config = {
                    self.source_name: {
                        'url': url,
                        'indicator': indicator or 'indicator',
                        'extractor': extractor or '@',
                    }}

            # Request related attributes
            self.url = url
            self.verify = not insecure
            self.auth: Optional[tuple[str, str]] = None
            self.headers = self.parse_headers(headers)

            if credentials:
                username = credentials.get('identifier', '')
                if username.startswith('_header:'):
                    header_name = username.split(':')[1]
                    header_value = credentials.get('password', '')
                    self.headers[header_name] = header_value
                else:
                    password = credentials.get('password', '')
                    if username is not None and password is not None:
                        self.auth = (username, password)

            self.cert = (cert_file, key_file) if cert_file and key_file else None
            self.tlp_color = tlp_color
            self.post_data = data

            if isinstance(self.post_data, str):
                content_type_header = 'Content-Type'
                if content_type_header.lower() not in [k.lower() for k in self.headers]:
                    self.headers[content_type_header] = 'application/x-www-form-urlencoded'

        @staticmethod
        def parse_headers(headers: Optional[Union[dict, str]]) -> dict:
            """Parse headers if passed as a string. Support a multiline string where each line contains a header
            of the format 'Name: Value'

            Args:
                headers (Optional[Union[dict, str]]): either dict or string to parse

            Returns:
                dict: returns a headers dict or None
            """
            if not headers:
                return {}
            if isinstance(headers, str):
                res = {}
                for line in headers.splitlines():
                    if line.strip():  # ignore empty lines
                        key_val = line.split(':', 1)
                        res[key_val[0].strip()] = key_val[1].strip()
                return res
            else:
                return headers

        def build_iterator(self, feed: dict, feed_name: str, **kwargs) -> Tuple[List, bool]:
            url = feed.get('url', self.url)

            if is_demisto_version_ge('6.5.0'):
                prefix_feed_name = get_formatted_feed_name(feed_name)  # Support for AWS feed

                # Set the If-None-Match and If-Modified-Since headers
                # if we have etag or last_modified values in the context, with server version higher than 6.5.0.
                last_run = demisto.getLastRun()
                etag = last_run.get(prefix_feed_name, {}).get('etag') or last_run.get(feed_name, {}).get('etag')
                last_modified = last_run.get(prefix_feed_name, {}).get('last_modified') or last_run.get(feed_name, {}).get('last_modified')  # noqa: E501
                last_updated = last_run.get(prefix_feed_name, {}).get('last_updated') or last_run.get(feed_name, {}).get('last_updated')  # noqa: E501
                # To avoid issues with indicators expiring, if 'last_updated' is over X hours old,
                # we'll refresh the indicators to ensure their expiration time is updated.
                # For further details, refer to : https://confluence-dc.paloaltonetworks.com/display/DemistoContent/Json+Api+Module
                if last_updated and has_passed_time_threshold(timestamp_str=last_updated, seconds_threshold=THRESHOLD_IN_SECONDS):
                    last_modified = None
                    etag = None
                    demisto.debug("Since it's been a long time with no update, to make sure we are keeping the indicators alive, \
                        we will refetch them from scratch")

                if etag:
                    self.headers['If-None-Match'] = etag

                if last_modified:
                    self.headers['If-Modified-Since'] = last_modified

            result = []
            if not self.post_data:
                r = requests.get(
                    url=url,
                    verify=self.verify,
                    auth=self.auth,
                    cert=self.cert,
                    headers=self.headers,
                    **kwargs
                )
            else:
                r = requests.post(
                    url=url,
                    data=self.post_data,
                    verify=self.verify,
                    auth=self.auth,
                    cert=self.cert,
                    headers=self.headers,
                    **kwargs
                )

            try:
                r.raise_for_status()
                if r.content:
                    demisto.debug(f'JSON: found content for {feed_name}')
                    data = r.json()
                    result = jmespath.search(expression=feed.get('extractor'), data=data)

            except ValueError as VE:
                raise ValueError(f'Could not parse returned data to Json. \n\nError massage: {VE}')
            if is_demisto_version_ge('6.5.0'):
                return result, get_no_update_value(r, feed_name)
            return result, True


    def get_no_update_value(response: requests.Response, feed_name: str) -> bool:
        """
        detect if the feed response has been modified according to the headers etag and last_modified.
        For more information, see this:
        https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
        https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
        Args:
            response: (requests.Response) The feed response.
            feed_name: (str) the name of the feed.
        Returns:
            boolean with the value for noUpdate argument.
            The value should be False if the response was modified.
        """
        # HTTP status code 304 (Not Modified) set noUpdate to True.
        if response.status_code == 304:
            demisto.debug('No new indicators fetched, createIndicators will be executed with noUpdate=True.')
            return True

        etag = response.headers.get('ETag')
        last_modified = response.headers.get('Last-Modified')
        current_time = datetime.utcnow()
        # Save the current time as the last updated time. This will be used to indicate the last time the feed was updated in XSOAR.
        last_updated = current_time.strftime(DATE_FORMAT)

        if not etag and not last_modified:
            demisto.debug('Last-Modified and Etag headers are not exists,'
                          'createIndicators will be executed with noUpdate=False.')
            return False

        last_run = demisto.getLastRun()
        last_run[feed_name] = {
            'last_modified': last_modified,
            'etag': etag,
            'last_updated': last_updated
        }
        demisto.setLastRun(last_run)
        demisto.debug(f'JSON: The new last run is: {last_run}')
        demisto.debug('New indicators fetched - the Last-Modified value has been updated,'
                      ' createIndicators will be executed with noUpdate=False.')
        return False


    def get_formatted_feed_name(feed_name: str):
        """support for AWS Feed config name, that contains $$ in the name.
            example: AMAZON$$CIDR
        Args:
            feed_name (str): The feed config name
        """
        prefix_feed_name = ''
        if '$$' in feed_name:
            prefix_feed_name = feed_name.split('$$')[0]
            return prefix_feed_name

        return feed_name


    def test_module(client: Client, limit) -> str:  # pragma: no cover
        for feed_name, feed in client.feed_name_to_config.items():
            custom_build_iterator = feed.get('custom_build_iterator')
            if custom_build_iterator:
                custom_build_iterator(client, feed, limit)
            else:
                client.build_iterator(feed, feed_name)
        return 'ok'


    def fetch_indicators_command(client: Client, indicator_type: str, feedTags: list, auto_detect: bool,
                                 create_relationships: bool = False, limit: int = 0, remove_ports: bool = False,
                                 **kwargs) -> Tuple[List[dict], bool]:
        """
        Fetches the indicators from client.
        :param client: Client of a JSON Feed
        :param indicator_type: the default indicator type
        :param feedTags: the indicator tags
        :param auto_detect: a boolean indicates if we should automatically detect the indicator_type
        :param limit: given only when get-indicators command is running. function will return number indicators as the limit
        :param create_relationships: whether to add connected indicators
        """
        indicators: List[dict] = []
        feeds_results = {}
        no_update = False
        for feed_name, feed in client.feed_name_to_config.items():
            custom_build_iterator = feed.get('custom_build_iterator')
            if custom_build_iterator:
                indicators_from_feed = custom_build_iterator(client, feed, limit, **kwargs)
                if not isinstance(indicators_from_feed, list):
                    raise Exception("Custom function to handle with pagination must return a list type")
                feeds_results[feed_name] = indicators_from_feed
            else:
                feeds_results[feed_name], no_update = client.build_iterator(feed, feed_name, **kwargs)

        indicators_values: Set[str] = set()
        indicators_values_indexes = {}

        for service_name, items in feeds_results.items():
            feed_config = client.feed_name_to_config.get(service_name, {})
            indicator_field = str(feed_config.get('indicator') if feed_config.get('indicator') else 'indicator')
            indicator_type = str(feed_config.get('indicator_type', indicator_type))
            use_prefix_flat = bool(feed_config.get('flat_json_with_prefix', False))
            mapping_function = feed_config.get('mapping_function', indicator_mapping)
            handle_indicator_function = feed_config.get('handle_indicator_function', handle_indicator)
            create_relationships_function = feed_config.get('create_relations_function')
            service_name = get_formatted_feed_name(service_name)

            for item in items:
                if isinstance(item, str):
                    item = {indicator_field: item}

                indicator_value = item.get(indicator_field)
                if indicator_value is None:
                    continue
                if indicator_value not in indicators_values:
                    indicators_values_indexes[indicator_value] = len(indicators_values)
                    indicators_values.add(indicator_value)
                else:
                    service = indicators[indicators_values_indexes[indicator_value]].get('rawJSON', {}).get('service', '')
                    if service and service_name not in service.split(','):
                        service_name += f', {service}'
                    indicators[indicators_values_indexes[indicator_value]]['rawJSON']['service'] = service_name
                    continue

                indicators.extend(
                    handle_indicator_function(client, item, feed_config, service_name, indicator_type, indicator_field,
                                              use_prefix_flat, feedTags, auto_detect, mapping_function,
                                              create_relationships, create_relationships_function, remove_ports))

                if limit and len(indicators) >= limit:  # We have a limitation only when get-indicators command is
                    # called, and then we return for each service_name "limit" of indicators
                    break
        return indicators, no_update


    def indicator_mapping(mapping: Dict, indicator: Dict, attributes: Dict):
        for map_key in mapping:
            if map_key in attributes:
                fields = mapping[map_key].split(".")
                if len(fields) > 1:
                    if indicator['fields'].get(fields[0]):
                        indicator['fields'][fields[0]][0].update({fields[1]: attributes.get(map_key)})
                    else:
                        indicator['fields'][fields[0]] = [{fields[1]: attributes.get(map_key)}]
                else:
                    indicator['fields'][mapping[map_key]] = attributes.get(map_key)  # type: ignore


    def handle_indicator(client: Client, item: Dict, feed_config: Dict, service_name: str,
                         indicator_type: str, indicator_field: str, use_prefix_flat: bool,
                         feedTags: list, auto_detect: bool, mapping_function: Callable = indicator_mapping,
                         create_relationships: bool = False, relationships_func: Callable = None,
                         remove_ports: bool = False) -> List[dict]:
        indicator_list = []
        mapping = feed_config.get('mapping')
        take_value_from_flatten = False
        indicator_value = item.get(indicator_field)
        if not indicator_value:
            take_value_from_flatten = True
        current_indicator_type = determine_indicator_type(indicator_type, auto_detect, indicator_value)

        if not current_indicator_type:
            demisto.debug(f'Could not determine indicator type for value: {indicator_value} from field: {indicator_field}.'
                          f' Skipping item: {item}')
            return []

        indicator = {
            'type': current_indicator_type,
            'fields': {
                'tags': feedTags,
            }
        }

        if client.tlp_color:
            indicator['fields']['trafficlightprotocol'] = client.tlp_color

        attributes = {'source_name': service_name, 'type': current_indicator_type}
        attributes.update(extract_all_fields_from_indicator(item, indicator_field,
                                                            flat_with_prefix=use_prefix_flat))

        if take_value_from_flatten:
            indicator_value = attributes.get(indicator_field)
        indicator['value'] = indicator_value
        attributes['value'] = indicator_value
        if mapping:
            mapping_function(mapping, indicator, attributes)

        if create_relationships and relationships_func and feed_config.get('relation_name'):
            indicator['relationships'] = relationships_func(feed_config, mapping, attributes)

        if feed_config.get('rawjson_include_indicator_type'):
            item['_indicator_type'] = current_indicator_type

        if remove_ports and indicator['type'] == 'IP' and indicator['value']:
            indicator['value'] = indicator['value'].split(':')[0]

        indicator['rawJSON'] = item

        indicator_list.append(indicator)

        return indicator_list


    def determine_indicator_type(indicator_type, auto_detect, value):
        """
        Detect the indicator type of the given value.
        Args:
            indicator_type: (str) Given indicator type.
            auto_detect: (bool) True whether auto detection of the indicator type is wanted.
            value: (str) The value which we'd like to get indicator type of.
        Returns:
            Str which stands for the indicator type after detection.
        """
        if auto_detect:
            indicator_type = auto_detect_indicator_type(value)
        return indicator_type


    def extract_all_fields_from_indicator(indicator: Dict, indicator_key: str, flat_with_prefix: bool = False) -> Dict:
        """Flattens the JSON object to create one dictionary of values
        Args:
            indicator(dict): JSON object that holds indicator full data.
            indicator_key(str): The key that holds the indicator value.
            flat_with_prefix(bool): Indicates whether should add the inner json path as part of the keys in the flatten json
        Returns:
            dict. A dictionary of the fields in the JSON object.
        """
        fields = {}  # type: dict

        def insert_value_to_fields(key, value):
            if key in fields:
                if not isinstance(fields[key], list):
                    fields[key] = [fields[key]]
                fields[key].append(value)
            else:
                fields[key] = value

        def extract(json_element, prefix_field="", use_prefix=False):
            if isinstance(json_element, dict):
                for key, value in json_element.items():
                    if value and isinstance(value, dict):
                        if use_prefix:
                            extract(value, prefix_field=f"{prefix_field}_{key}" if prefix_field else key,
                                    use_prefix=use_prefix)
                        else:
                            extract(value)
                    elif key != indicator_key:
                        if use_prefix:
                            insert_value_to_fields(f"{prefix_field}_{key}" if prefix_field else key, value)
                        else:
                            insert_value_to_fields(key, value)
            elif json_element and indicator_key not in json_element:
                for key, value in json_element:
                    insert_value_to_fields(key, value)

        extract(indicator, use_prefix=flat_with_prefix)

        return fields


    def feed_main(params, feed_name, prefix):  # pragma: no cover
        handle_proxy()
        client = Client(**params)
        indicator_type = params.get('indicator_type')
        auto_detect = params.get('auto_detect_type')
        feedTags = argToList(params.get('feedTags'))
        limit = int(demisto.args().get('limit', 10))
        command = demisto.command()
        if prefix and not prefix.endswith('-'):
            prefix += '-'
        if command != 'fetch-indicators':
            demisto.info(f'Command being called is {demisto.command()}')
        try:
            if command == 'test-module':
                return_results(test_module(client, limit))

            elif command == 'fetch-indicators':
                remove_ports = argToBoolean(params.get('remove_ports', False))
                create_relationships = params.get('create_relationships')
                indicators, no_update = fetch_indicators_command(client, indicator_type, feedTags, auto_detect,
                                                                 create_relationships, remove_ports=remove_ports)

                # check if the version is higher than 6.5.0 so we can use noUpdate parameter
                if is_demisto_version_ge('6.5.0'):
                    if not indicators:
                        demisto.createIndicators(indicators, noUpdate=no_update)
                    else:
                        for b in batch(indicators, batch_size=2000):
                            demisto.createIndicators(b, noUpdate=no_update)

                else:
                    # call createIndicators without noUpdate arg
                    if not indicators:
                        demisto.createIndicators(indicators)
                    else:
                        for b in batch(indicators, batch_size=2000):
                            demisto.createIndicators(b)

            elif command == f'{prefix}get-indicators':
                remove_ports = argToBoolean(demisto.args().get('remove_ports', False))
                create_relationships = params.get('create_relationships')
                indicators, _ = fetch_indicators_command(client, indicator_type, feedTags, auto_detect,
                                                         create_relationships, limit, remove_ports)
                hr = tableToMarkdown('Indicators', indicators, headers=['value', 'type', 'rawJSON'])
                return_results(CommandResults(readable_output=hr, raw_response=indicators))

        except Exception as err:
            err_msg = f'Error in {feed_name} integration [{err}]'
            return_error(err_msg)

    register_module_line('JSONFeedApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###
    INTEGRATION_NAME = "MalwareBazaar Feed"


    def custom_mapping_function(mapping: Dict, indicator: Dict, attributes: Dict):
        for map_key in mapping:
            if map_key in attributes:
                fields = mapping[map_key].split(".")
                if len(fields) > 1:
                    if indicator['fields'].get(fields[0]):
                        indicator['fields'][fields[0]][0].update({fields[1]: attributes.get(map_key)})
                    else:
                        indicator['fields'][fields[0]] = [{fields[1]: attributes.get(map_key)}]
                else:
                    indicator['fields'][mapping[map_key]] = attributes.get(map_key)
            if map_key == 'url_download':
                indicator['fields']['downloadurl'] = f"{mapping[map_key]}{indicator['value']}/"


    def custom_build_relationships(feed_config: Dict, _mapping: Dict, indicator_data: Dict) -> List[dict]:
        if indicator_data.get(feed_config.get('relation_entity_b')):
            relationships_lst = EntityRelationship(
                name=feed_config.get('relation_name'),
                entity_a=indicator_data.get('value'),
                entity_a_type=indicator_data.get('type'),
                entity_b=indicator_data.get(feed_config.get('relation_entity_b')),
                entity_b_type=feed_config.get('relation_entity_b_type'),
                reverse_name=feed_config.get('reverse_relationship_name')
            )
            return [relationships_lst.to_indicator()]
        return []


    def main() -> None:
        params = {k: v for k, v in demisto.params().items() if v is not None}
        params['indicator_type'] = FeedIndicatorType.File
        params['feed_name_to_config'] = {
            'File': {
                'url': f'{params.get("url")}/api/v1/',
                'extractor': "data",
                'indicator': 'sha256_hash',
                'indicator_type': FeedIndicatorType.File,
                'relation_name': EntityRelationship.Relationships.INDICATOR_OF,
                'reverse_relationship_name': EntityRelationship.Relationships.INDICATED_BY,
                'relation_entity_b': 'signature',
                'relation_entity_b_type': 'Malware',
                'create_relations_function': custom_build_relationships,
                'mapping_function': custom_mapping_function,
                'mapping': {
                    'sha256_hash': 'sha256',
                    'sha1_hash': 'sha1',
                    'md5_hash': 'md5',
                    'first_seen': 'first_seen_by_source',
                    'last_seen': 'last_seen_by_source',
                    'file_name': 'Associated File Names',
                    'file_size': 'size',
                    'file_type': 'filetype',
                    'reporter': 'reported_by',
                    'imphash': 'imphash',
                    'ssdeep': 'ssdeep',
                    'tags': 'tags',
                    'url_download': 'https://bazaar.abuse.ch/sample/'
                }
            }
        }
        params['data'] = {'query': 'get_recent',
                          'selector': 'time'}  # query params to get only the recent changes for the incremental feed
        feed_main(params, 'MalwareBazaar Feed', 'malwarebazzar')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('MalwareBazaar Feed', 'end', __line__())
  subtype: python3
  type: python
system: true
