category: Data Enrichment & Threat Intelligence
commonfields:
  id: Create-Mock-Feed-Relationships
  version: -1
configuration:
- display: Indicator Type
  name: indicator_type
  options:
  - Domain
  - File
  - IP
  - URL
  required: true
  type: 16
- defaultvalue: "100000"
  display: Amount of indicators
  name: amount_indicators
  required: false
  type: 0
- defaultvalue: "true"
  display: Incremental Feed
  hidden: true
  name: feedIncremental
  required: false
  type: 8
- defaultvalue: "200"
  display: Indicators custom field length
  name: indicators_custom_field_length
  required: false
  type: 0
- defaultvalue: "1"
  display: Amount of relationships per indicator
  name: amount_relationships
  required: false
  type: 0
- defaultvalue: "1"
  display: Relationship description length
  name: relationship_description_length
  required: false
  type: 0
- defaultvalue: "30000"
  display: Size of batches
  name: batch_size
  required: false
  type: 0
- display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- display: Incidents name
  name: incidents_name
  required: false
  type: 0
- additionalinfo: Make sure to have the key "indicator" in the appropriate CSV column
    where the value of the indicator is expected to be
  defaultvalue: indicator,description,date
  display: Fieldnames (CSV)
  name: fieldnames
  required: false
  type: 0
- display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 1.3.15
    packID: DeveloperTools
    packName: Developer Tools
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Mock Feed
detaileddescription: |
  ### Community Contributed Integration
   #### Integration Author: Cortex XSOAR
   No support or maintenance is provided by the author. Customers are encouraged to engage with the user community for questions and guidance at the [Cortex XSOAR Live Discussions](https://live.paloaltonetworks.com/t5/cortex-xsoar-discussions/bd-p/Cortex_XSOAR_Discussions).
  ***
display: Create-Mock-Feed-Relationships (Community Contribution)
image: data:image/png;base64,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
name: Create-Mock-Feed-Relationships
script:
  dockerimage: demisto/feed-performance-test:1.0.46565
  feed: true
  runonce: false
  script: |
    register_module_line('Create-Mock-Feed-Relationships', 'start', __line__())
    ### pack version: 1.3.15


    import csv
    import itertools
    from pathlib import Path
    from time import perf_counter as timer

    import urllib3


    # disable insecure warnings
    urllib3.disable_warnings()

    REGEX = OrderedDict()
    REGEX['IP'] = ipv4Regex
    REGEX['Domain'] = r'([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}'
    REGEX['Email'] = emailRegex
    REGEX['URL'] = urlRegex
    REGEX['File'] = r'\b[a-fA-F\d]{64}|[a-fA-F\d]{40}|[a-fA-F\d]{32}|[a-fA-F\d]{128}\b'

    TYPE_TO_FILENAME = OrderedDict()
    TYPE_TO_FILENAME['IP'] = 'ips.csv'
    TYPE_TO_FILENAME['Domain'] = 'domains.csv'
    TYPE_TO_FILENAME['URL'] = 'domains.csv'
    TYPE_TO_FILENAME['File'] = 'hashes.csv'


    def create_run_info(batches=[], total_indicators=0, total_feed_time=0):
        return {
            "batches": batches,
            "total_indicators": total_indicators,
            "total_feed_time": total_feed_time
        }


    def create_batch(size=None, time=None):
        return {
            "size": size,
            "time": time
        }


    def get_indicator_type(item):
        for indicator_type, pattern in REGEX.items():
            if re.match(pattern, str(item)):
                return indicator_type
        return ''


    def build_iterator(f, fieldnames, dialect):
        csvreader = csv.DictReader(
            f,
            fieldnames=fieldnames,
            **dialect
        )
        return csvreader


    def good_batch(iterable, size):
        it = iter(iterable)
        while True:
            chunk = tuple(itertools.islice(it, size))
            if not chunk:
                break
            yield chunk


    def generate_dbotscore(indicator, indicator_type):
        the_hash = hash(indicator)
        last_digit = abs(the_hash) % 10
        if last_digit < 5:
            score = 1
        elif last_digit < 8:
            score = 2
        else:
            score = 3
        return {
            "Indicator": indicator,
            "Type": indicator_type,
            "Vendor": "Bar Saar",
            "Score": score
        }


    def main():
        if demisto.command() == 'fetch-indicators':
            indicator_types = argToList(demisto.params().get('indicator_type'))

            integration_context = get_integration_context()
            if not indicator_types:
                indicator_types = ['IP']
            amount_indicators = int(demisto.getParam('amount_indicators'))
            demisto.info(f'starting feed with types {indicator_types}')
            demisto.info(f'starting feed with types {amount_indicators} size')
            for indicator_type in indicator_types:
                if int(integration_context.get(indicator_type, 0)) >= amount_indicators:
                    continue
                indicators = []
                csv_file = TYPE_TO_FILENAME[indicator_type]
                indicators_csv_file = open(Path('/perf/' + csv_file), newline='')
                fieldnames = argToList(demisto.params().get('fieldnames'))
                dialect = {
                    'delimiter': demisto.params().get('delimiter', ','),
                    'doublequote': demisto.params().get('doublequote', True),
                    'escapechar': demisto.params().get('escapechar', None),
                    'quotechar': demisto.params().get('quotechar', '"'),
                    'skipinitialspace': demisto.params().get('skipinitialspace', False)
                }
                iterator = build_iterator(indicators_csv_file, fieldnames, dialect)
                count = 0
                if indicator_type == "Domain":
                    prev_indicator = "google.com"
                    prev_type = "Domain"
                elif indicator_type == "IP":
                    prev_indicator = "8.8.8.8"
                    prev_type = "IP"
                elif indicator_type == "File":
                    prev_indicator = "82660430ab3d496ee4c8d4711e23174bbda0dbf7883cb0c0871f80851e1b34e0"
                    prev_type = "File"
                elif indicator_type == "URL":
                    prev_indicator = "https://www.google.com"
                    prev_type = "URL"
                for item in iterator:
                    if 'indicator' in item:
                        indicator_val = item.get('indicator') if indicator_type != 'URL' else f"https://www.{item.get('indicator')}"
                        count += 1
                        raw_json = dict(item)
                        raw_json['value'] = indicator_val
                        raw_json['type'] = indicator_type
                        generatedDescription = "x" * int(demisto.getParam('indicators_custom_field_length'))
                        fields = {
                            "domainname": generatedDescription
                        }
                        currentIndicator = {
                            "value": indicator_val,
                            "type": indicator_type,
                            "rawJSON": {},
                            "fields": fields
                        }
                        currentRelationships = []
                        for x in range(int(demisto.getParam('amount_relationships'))):
                            currentRelationship = {
                                "name": "Relates to",
                                "reverseName": "Relates from",
                                "type": "uses",
                                "entityA": indicator_val,
                                "entityAFamily": "indicator",
                                "objectTypeA": indicator_type,
                                "entityB": "{}".format(x) + prev_indicator,
                                "entityBFamily": "indicator",
                                "objectTypeB": prev_type,
                                "fields": {
                                    "revoked": False,
                                    "firstSeenBySource": datetime.now().isoformat('T'),
                                    "lastSeenBySource": datetime.now().isoformat('T'),
                                    "description": "x" * int(demisto.getParam('relationship_description_length'))
                                }
                            }
                            currentRelationships.append(currentRelationship)
                        currentIndicator['relationships'] = currentRelationships
                        indicators.append(currentIndicator)
                        prev_indicator = indicator_val
                        prev_type = indicator_type
                        if count == amount_indicators:
                            break
                    else:
                        raise Exception("abc")

                batch_size = int(demisto.params().get('batch_size'))
                batches = []
                feed_start = timer()
                indicators = indicators[:amount_indicators]
                demisto.info(f'starting feed of {len(indicators)} size')
                for b in good_batch(indicators, batch_size):
                    batch_start = timer()
                    demisto.createIndicators(b)
                    batch_end = timer()
                    batch_time = batch_end - batch_start
                    batch_info = create_batch(len(b), batch_time)
                    batches.append(batch_info)
                feed_end = timer()
                demisto.info('finished feed')
                feed_total_time = feed_end - feed_start
                run_info = create_run_info(batches, len(indicators), feed_total_time)
                incidents = [{"name": demisto.params().get('incidents_name'), "type": "Access", "details": json.dumps(run_info)}]
                demisto.createIncidents(incidents)
                demisto.info('feed finished create result incident')
                integration_context[indicator_type] = amount_indicators
                set_integration_context(integration_context)
        elif demisto.command() == 'test-module':
            demisto.results('ok')
        elif demisto.command() == 'random-score-indicators':
            indicators = argToList(demisto.args().get('indicators')) or []
            dbot_scores = [generate_dbotscore(i, get_indicator_type(i)) for i in indicators]
            ec = {}
            ec['DBotScore'] = dbot_scores
            md = tableToMarkdown("Indicator DBot Score", ec["DBotScore"])
            demisto.results({
                "Type": 1,
                "ContentsFormat": "json",
                "Contents": ec,
                "HumanReadable": md,
                "EntryContext": ec
            })


    # python2 uses __builtin__ python3 uses builtin s
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()

    register_module_line('Create-Mock-Feed-Relationships', 'end', __line__())
  subtype: python3
  type: python
system: true
