args:
- description: Additional text by which to query incidents.
  name: query
- description: The field name with the label. Supports a comma-separated list, the
    first non-empty value will be taken.
  name: tagField
  required: true
- defaultValue: '*'
  description: 'A comma-separated list of email tag values and mapping. The script
    considers only the tags specified in this field. You can map a label to another
    value by using this format: LABEL:MAPPED_LABEL. For example, for 4 values in an
    email tag: malicious, credentials harvesting, inner communication, external legit
    email, unclassified. While training, we want to ignore the "unclassified" tag,
    and refer to "credentials harvesting" as "malicious" too. Also, we want to merge
    "inner communication" and "external legit email" to one tag called "non-malicious".
    The input will be: malicious, credentials harvesting:malicious, inner communication:non-malicious,
    external legit email:non-malicious.'
  name: phishingLabels
comment: A helper script for the DBot Create Phishing Classifier V2 playbook. This
  script extends the query based on the phishingLabels argument.
commonfields:
  id: ExtendQueryBasedOnPhishingLabels
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.4.9
    packID: ML
    packName: Machine Learning
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
dockerimage: demisto/python3:3.10.12.63474
enabled: true
engineinfo: {}
mainengineinfo: {}
name: ExtendQueryBasedOnPhishingLabels
outputs:
- contextPath: ExtendQueryBasedOnPhishingLabels.extendedQuery
  description: The original query extended by a part which takes into account the
    phishingLabels argument.
  type: Unknown
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('ExtendQueryBasedOnPhishingLabels', 'start', __line__())
  ### pack version: 1.4.9


  ALL_LABELS = "*"


  def get_phishing_map_labels(comma_values):
      if comma_values == ALL_LABELS:
          return comma_values
      values = [x.strip() for x in comma_values.split(",")]
      labels_dict = {}
      for v in values:
          v = v.strip()
          if ":" in v:
              splited = v.rsplit(":", maxsplit=1)
              labels_dict[splited[0].strip()] = splited[1].strip()
          else:
              labels_dict[v] = v
      return {k: v for k, v in labels_dict.items()}


  def build_query_in_reepect_to_phishing_labels(args):
      mapping = args.get('phishingLabels', ALL_LABELS)
      tag_field = args['tagField']
      query = args.get('query', '')
      if mapping == ALL_LABELS:
          mapping_query = '{}:*'.format(tag_field)
      else:
          mapping_dict = get_phishing_map_labels(mapping)
          tags_union = ' '.join(['"{}"'.format(label) for label in mapping_dict])
          mapping_query = '{}:({})'.format(tag_field, tags_union)
      if query == '':
          modified_query = mapping_query
      else:
          modified_query = '({}) and ({})'.format(query, mapping_query)
      return modified_query


  def main():
      try:
          result = {'extendedQuery': build_query_in_reepect_to_phishing_labels(demisto.args())}

          res = CommandResults(
              outputs_prefix='ExtendQueryBasedOnPhishingLabels',
              outputs_key_field='',
              outputs=result,
          )
          return_results(res)
      except Exception as ex:
          demisto.error(traceback.format_exc())  # print the traceback
          return_error(f'Failed to execute ExtendQueryBasedOnPhishingLabels. Error: {str(ex)}')


  ''' ENTRY POINT '''


  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()

  register_module_line('ExtendQueryBasedOnPhishingLabels', 'end', __line__())
scripttarget: 0
subtype: python3
system: true
tags:
- ml
type: python
