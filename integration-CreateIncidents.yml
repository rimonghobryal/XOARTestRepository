category: Utilities
commonfields:
  id: CreateIncidents
  version: -1
configuration:
- additionalinfo: The base url of the source you wish to upload/ downlowd files from.
  defaultvalue: https://raw.github.com/demisto/content/master
  display: Source URL
  name: url
  required: false
  section: Connect
  type: 0
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.1.0
    itemVersion: 1.3.15
    packID: DeveloperTools
    packName: Developer Tools
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: CreateIncidents fetches custom incidents that are created manually.
detaileddescription: "### Community Contributed Integration\n #### Integration Author:
  Cortex XSOAR\n No support or maintenance is provided by the author. Customers are
  encouraged to engage with the user community for questions and guidance at the [Cortex
  XSOAR Live Discussions](https://live.paloaltonetworks.com/t5/cortex-xsoar-discussions/bd-p/Cortex_XSOAR_Discussions).\n***\n##
  CreateIncidents Help\n\n#### Create a new instance\n1. Fill the field *Source URL*
  with according to the platform you are using for storing files. \n   Currently only
  Github is supported, with paths in the Content repository.\n2. Check *fetch-incidents*
  in order for incidents to be processes.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/create-incidents)"
display: Create Test Incidents (Community Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAABGdBTUEAALGPC/xhBQAACYJJREFUeAHtmwmMVdUdhw8zDDMKjIAgIohIRUaghBSLGmWJWGONaAON2CUmik2pTRu7poCEqq3VtjY2FlvcWqRY1BRJwaWtSSmWxYgooAiOwAAKZREBkZ2Zft+bd8jlOW8YMhSYy/sl39yz3bP8/+eee++5b0IoqGCBlFhgJON4GWbBNSkZU2EYWQtcFYqbVYVfXLUwjB+0IDQLG0jveypYp+hUGCRjHBqG9awKX+jeP9xQcUno32kFaVecCmM/VRy8MPx7TeusQ6vDko2dCS8qOLjpWqA5XX8YtsAemBq27zkn1ITqsHHn5rCvWgd7LzZ/JUyAVKpZKkcVwujQqsXtYcrwtqFjqw6ZMZYWtcDBtePdX7037Nz3SSZ93fZNYfTMEpw+hvizabNHWpfo/mFEr4/CueVdQoui0gzRuXqwhLS2Ze0y9O1YEa69cB2pl6XNuY7HpSyNKsKpR16dDlTvD9v3bgunl1i2JI2GSJODb8JBo+Aj6BCKmtXv4MmL54aHXu2dderFHJ/LhlN1SIuDB/Kee3+4d+iWULm1NDz9VjmvRG3yemrzrk04twf5A6AS2oMPXKlTWhw8jPvoqjC0+xDgEcsLsh7NXbua3I2gc1UqnevA0vKQtSwsWl/GM3JN2HPgkzB1ybzgk3I+9Wjn1d0L0jLB8400+9qQN7vJZLSipzN4sDofx7bEzcVh7BXvheG9Ls07guHT5oe1O/aTPw909n0wH1Kl4pSMZh/jmBoO1rzE0Q2ObqFfpzNCv7O75h3fyD6dQ3npBl6VOoWS4tPC5l1nUfbFvOWbaEaalqiD+GD5IT/UHArlCxSFm/rUvvs+uGBOWLY5LZP9sPGm5R582KCIvB/mrNbhDdPsKt+BqxpWuGmVqv9dsWmNJdnbc4jMDWXNd4fWLXZmMrqU7wqPXT+Ie/SBcPP0BWHz7paZ9J1725K2g/Bg2J5JS9GfNC3RSbesJ9KbJ+qLwQewPuHD3d/lHl2d+eBQubWC452krwKd+ib4wJU6pXWJ1lG7YA68AGew8VHJ7lZxZh96QOe3SfNVyV94vAapdC7jSs17sGOpT2vCog0tg3vPew/s5oGqHYXd7CgoJRbwCXkKfJhlYkrGVRhGjgX8VUftw1VORlqjaXiKdrn9OgyE7lANm2Au/BVWQEOlPZwAtU/eDT2rUO7/ZgF/CuuHArc18rGUvF/CrTAE3N0qgqScHM/DdPgxeKWfC2l9y2BoJ78eo4v5nHqkdD9EeGX/Da6E06EDuHf9O/Dqvwe6QUEnyAIuxUdyZEPy/Y20+i342nQdlMJwmAa+K38PCjrOFvADQ0McaJn6JsOsbL/P5OgHB69cnZ6s23flgo6zBXbTXtIJ+cL/oFx/uADcwuwIneEz0B18qHKZ/j3UVafn94GCjrMFfNLN59QjpXv176nnfHfBHoXeUNAJssA22j2SI482/wPqHAftT9CYCs0mLOCu1NE6MF9577FfAz8bpkpNeaPjLTyxGJ6EN+Bj8B7bE/zPwc9BJ/AeK2Xge20x+Jq0AzxvEvhaVFDBAgULFCxQsEDBAgULFCxwTC3gK4EPJrkc00YaUdnVnLsWhh5lHXFcTfWDwU8Z73+g9CjHfVjxImLfAX9umot5J4NOoxN+2fF4NIrj8sm6ITqPQrPhooYUPsZl6mrbp31p1JtOcnaPoLL/Jjru/u2ppO4MdjCUn4BB19X2ePohjVLyKl1ITf4bR8SN99fhV6DshO+et4GzahTMB3eUZkFyCfVXiuZPBjckZoPvpL+BDfAMXABRlh8LM8D6FkB9+786ws0J32VnQwUcSfdT4HH4JrhaLYUbQfkFyTz1F1iUCdXuW08j7L+kvgv+sCBqIAHt45bnSvCHfL5XK9t6BCy/Dn4EA2A6rAfL+oVK++dr2zqsP0p/PAXa0y9cP4FiUFeCdWqX2eCF6vktINwFNXAn3J6lN0c1AQ6Cm/VPgJ1100A9DXfDSNDR5kXtI7Af/gATwfrdiNBY92bjD3CMsrztTAXr1HHvgAa4ATxfQ6ieoFGfA9ueB048yyYVx9U1m2jdtrEANLhO2QiqFzge23ESagfrs2wl3AwPged/FspAp/8dtM0/QcPHCWNbxleDdvWcb8AUcMfMT5O2dRnU1TbJGVv48UPFvmwnPAGeAs8fAyraaBPhcTATzB8Chxy8k7CGlVGgnAHLYSHoBA2alA1fBF7lVtgXlGU1mLKMHXMSRK0gYJ1RlnfwUQ8TsD4nWux8dPCDpNlXHdcWvgyWTa4IRA+NK+lgJ4ZjUmPB8yqMoNFg/BIj6HIwfivYzpngODzPSRbzCGacZ7zcCNLB1fB5IznqRPxaMP9n2bzctk22jujg2BcnbdQSAjpURRtpC6Ut7M94jR/lTLKD8ng2UcNPAmfpKohOIxhugSp4CQaB6l57yPzVmMqBbIYYN20jaLSkLBe1PBvoGBMSxwsJu4qsga3wLKgOtYd6/zpox6Tsg2pTe/jUX9tR2sJ2toC2aQ+VsBq8EK4BJ8Hb4MURtZfAazHCsQ+8Ak7uO8Dxng8NUezLq4nChh1zsv/RxtHxbZIOTpx7KNiK0PfBjjprh4Kys0/Ao9AN7oZjqTjzq+qo9H3SdsHZUJIguUKQfNSKE6x59sx12aPOS7bzQ+KWnQXa5x54F4ZBfXqGTOvuDFdDnGgEM/V5jG0bTir2RbtHGXZCuarkVbLCEZTyvhE1g8AEaA194QV4BLyflILyfBtyiWmsXIa+COfB9eAM9SrRIKpH7SH8meNtMBHugxrQ2c9DY/RB9uSvcPSKnQurYBxsA5fEwfBH0OHfgjHwJHjlJK9eop9SGSnet7vAdWA8Krftd2JG9hj78m3iVVABXgSTwPHXq7vItVAuzsj9MBZUPzgAvzaCXBp96PgYfg6e/yVQzs7JmVDtn/c4/CsRn0N4ZSJu+cXg0mI9SyEuS06mZWDb0Si3ENYJljXdiZerOK6u2YypHOM9zaRR4PmXGkEl8AqY5hXaDpzMr4Np8ibECfdiIt28NXAHqNy2THMl2AbWre3eAMuputrOrcOLzElmW9rdid4KVLwHO3FUOVjuASONkfcjO9dY6eA/gStCNCDBQ2pGyHSPUYZ1XnR6TG/ssQsVOK6kOhBJpvUmvhNcavvB5fAyONnrs4d9bQP5VFfbuWU7kRAdm5t30sZzr/iTtqPZjn2Vo1fRjeDD4gBYDo19DqCKdGomw/pBExqatw3vf3HJ3ZCNn3WyjeF/PmPRmBKd/dAAAAAASUVORK5CYII=
name: CreateIncidents
script:
  commands:
  - arguments:
    - description: "The path of json file containing incidents. Can contain one incident\nor
        a list of incidents. For example: Packs/somePack/TestPlaybooks/examples.json'.
        \nIncidents without name will be named Mocked Incident."
      name: incidents_path
      required: true
    - description: 'The paths of the files to be added to incidents as attachment.
        Would be added to all incidents provided in the incident_path file. For example:
        Packs/somePack/TestPlaybooks/attach.eml'
      name: attachment_paths
    description: Creates incidents from json files provided, and stores it in the
      instance context.
    name: create-test-incident-from-file
  - arguments:
    - description: The enry ID of the json file that represents the incidents.
      name: incident_entry_id
    - description: The enry IDs of the incident attachments.
      isArray: true
      name: attachment_entry_ids
    - description: The json object that represents the incident.
      name: incident_raw_json
    - description: 'The paths of the files to be added to incidents as attachment.
        Would be added to all incidents provided in the incident_path file. For example:
        Packs/somePack/TestPlaybooks/attach.eml'
      name: attachment_paths
    description: Creates incidents from json file, and stores it in the instance context.
    name: create-test-incident-from-raw-json
  dockerimage: demisto/python3:3.10.14.90585
  isfetch: true
  runonce: false
  script: |
    register_module_line('CreateIncidents', 'start', __line__())
    ### pack version: 1.3.15
    import base64
    import json



    import pathlib
    from collections import namedtuple


    import urllib3
    from typing import Any

    # Disable insecure warnings
    urllib3.disable_warnings()  # pylint: disable=no-member

    ''' CONSTANTS '''

    Attachment = namedtuple('Attachment', ['name', 'content'])


    class Client(BaseClient):
        def __init__(self, base_url: str, use_ssl: bool, use_proxy: bool):
            self.base_url = base_url
            self.verify = use_ssl
            self.proxy = use_proxy
            headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}
            super().__init__(base_url, headers=headers, verify=self.verify, proxy=self.proxy)

        def http_request(self, file_path: str, response_type: str = 'json') -> Union[dict, str, list]:  # pragma: no cover
            try:
                data = self._http_request(
                    method='GET',
                    url_suffix=file_path,
                    resp_type=response_type,
                    return_empty_response=True,
                )
                return data
            except Exception as e:
                if '404' in str(e):
                    raise DemistoException('The requested file could not be found.')
                else:
                    raise e


    def test_module(client) -> str:  # pragma: no cover
        """ Getting README file just to see we manage to get a basic file. """
        message: str = ''
        try:
            client.http_request('README.md', 'content')
            message = 'ok'

        except DemistoException as e:
            if 'Forbidden' in str(e) or 'Authorization' in str(e):
                message = 'Authorization Error: make sure API Key is correctly set'
            else:
                raise e
        return message


    def fetch_incidents_command(client):
        """
        The fetch runs on instance's context, gets the formatted incidents, and add attachments if needed.
        It then clears the context so incident would not be duplicated.
        """
        data: dict = get_integration_context()
        incidents = data.pop('incidents', [])
        demisto.debug(f'Found {len(incidents)} incidents to fetch.')
        for incident in incidents:
            if 'attachment' in incident:
                _add_attachments(client, incident)
            if 'entry_id_attachment' in incident:
                for attachment_entry_id in incident['entry_id_attachment']:
                    file = fileResult(attachment_entry_id['name'], base64.b64decode(attachment_entry_id['content'].encode('utf-8')))
                    incident.setdefault('attachment', []).append({
                        'path': file['FileID'],
                        'name': attachment_entry_id['name']
                    })
                incident.pop('entry_id_attachment')

        # clear the integration contex from already seen incidents
        set_integration_context({'incidents': []})
        return incidents


    def _add_attachments(client, incident: dict):
        """
         This function takes a formatted incident and add an attachments in case it has one.
        """
        attachment_paths = incident['attachment']
        incident['attachment'] = []
        for attachment_path in attachment_paths:
            demisto.debug(f'Adding attachments from link {attachment_path}')

            attachment = Attachment(content=client.http_request(file_path=attachment_path, response_type='content'),
                                    name=pathlib.Path(attachment_path).name)
            file_result = fileResult(attachment.name, attachment.content)

            incident['attachment'].append({
                'path': file_result['FileID'],
                'name': attachment.name
            })


    def create_test_incident_from_file_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        This function will get the incidents and save the formatted incidents to instance context, for the fetch.
        """
        incidents_path = args.get('incidents_path')
        attachment_path = argToList(args.get('attachment_paths'))
        if not incidents_path:
            raise ValueError('Incidents were not specified')

        ready_incidents = get_incidents_from_file(attachment_path=attachment_path, incidents_path=incidents_path,
                                                  client=client)
        set_integration_context({'incidents': ready_incidents})
        return CommandResults(readable_output=f'Loaded {len(ready_incidents)} incidents from file.')


    def create_test_incident_from_json_command(args):
        """
        This function will get the incidents and save the formatted incidents to instance context, for the fetch.
        """
        incidents_entry_id = args.get('incident_entry_id')
        incidents_json = args.get('incident_raw_json')
        if (not incidents_entry_id and not incidents_json) or (incidents_entry_id and incidents_json):
            raise DemistoException('Please insert entry_id or incident_raw_json, and not both')
        if incidents_entry_id:
            incidents_file_path = demisto.getFilePath(incidents_entry_id)
            with open(incidents_file_path['path'], 'rb') as incidents_file:
                incidents = json.load(incidents_file)
        elif incidents_json:
            incidents = json.loads(incidents_json)

        attachment_path = argToList(args.get('attachment_paths'))
        attachment_entry_ids = argToList(args.get('attachment_entry_ids'))

        if not incidents:
            raise ValueError('Incidents were not specified')

        if not isinstance(incidents, list):
            incidents = [incidents]

        ready_incidents = parse_incidents(incidents, attachment_path, attachment_entry_ids)

        set_integration_context({'incidents': ready_incidents})
        return CommandResults(readable_output=f'Loaded {len(ready_incidents)} incidents from json.')


    def get_incidents_from_file(client: Client, incidents_path: str, attachment_path: List[str] = None):
        """
        This function retrieves the incidents from the file provided using the relevant client,
        handling the case of a single incident, it returns formatted incidents.
        """
        incidents = client.http_request(file_path=incidents_path, response_type='json')

        if not isinstance(incidents, list):
            incidents = [incidents]  # type: ignore

        ready_incidents = parse_incidents(incidents, attachment_path)
        return ready_incidents


    def parse_incidents(incidents: List[dict],
                        attachment_path: List[str] = None,
                        attachment_entry_ids: List[str] = None) -> List[dict]:
        """
        This function will take a list of incidents and make them in the format of XSoar format,
         as a preparation for the fetch command.
         Since fileResult only exists in the scope of the command, we only save the path to the file.
         The actual file is added at the fetch command.
        """
        ready_incidents = []

        for incident in incidents:
            parsed_incident = {
                'name': incident.get('name', 'Mocked Incident'),
                'occurred': incident.get('created'),
                'rawJSON': json.dumps(incident)
            }

            if incident.get('labels'):
                parsed_incident['labels'] = incident.get('labels')

            if attachment_path:
                parsed_incident['attachment'] = attachment_path

            if attachment_entry_ids:
                parsed_incident['entry_id_attachment'] = []
                for attachment_entry_id in attachment_entry_ids:
                    attachment = demisto.getFilePath(attachment_entry_id)
                    with open(attachment['path'], 'rb') as f:
                        attachment_content = f.read()
                        parsed_incident['entry_id_attachment'].append({
                            'content': base64.b64encode(attachment_content).decode('utf-8'),
                            'name': attachment['name']
                        })

            ready_incidents.append(parsed_incident)
        return ready_incidents


    ''' MAIN FUNCTION '''


    def main() -> None:  # pragma: no cover
        try:
            params = demisto.params()
            command = demisto.command()
            args = demisto.args()

            demisto.debug(f'Command being called is {command}')
            client = Client(
                base_url=params.get('url'),
                use_ssl=not params.get('insecure', True),
                use_proxy=params.get('proxy', False)
            )
            if command == 'fetch-incidents':
                incidents = fetch_incidents_command(client)
                demisto.incidents(incidents)

            elif command == 'test-module':
                result = test_module(client)
                return_results(result)

            elif command == 'create-test-incident-from-file':
                return_results(create_test_incident_from_file_command(client, args))

            elif command == 'create-test-incident-from-raw-json':
                return_results(create_test_incident_from_json_command(args))

        # Log exceptions and return errors
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}, {traceback.format_exc()}')


    ''' ENTRY POINT '''

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('CreateIncidents', 'end', __line__())
  subtype: python3
  type: python
system: true
